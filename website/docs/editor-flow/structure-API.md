---
id: structure-API
title: Structure API
sidebar_label: Structure API
---

## Basic app structure
After you bootstraped the app via create-yoshi-app, the structure will be similar to:
```
my-app
├── .application.json
├── package.json
└── src
    ├── viewer.app.ts
    ├── editor.app.ts
    ├── assets
    │   └── locales
    └── components
        └── MyComponent
            ├── .component.json
            ├── controller.ts
            ├── controller.spec.ts
            ├── Widget
            │   ├── index.ts
            │   ├── Widget.tsx
            │   ├── Widget.spec.ts
            │   ├── Widget.e2e.ts
            │   └── Widget.st.css
            └── Settings
                ├── index.ts
                ├── Settings.tsx
                ├── Settings.spec.ts
                ├── Settings.e2e.ts
                └── Settings.scss
```

## `.application.json`
Each app should contain `.application.json`. It's content will be auto-generated by `create-yoshi-app`.
It will be:
```
{
  appDefinitionId: 'YOUR_APP_DEFINITION_ID'
}
```
To use app configration values in runtime it's valid to:
```ts
import { appDefinitionId } from '../../.application.json';
```


## Application level
Under `src` directory located: `viewer.app.ts`, `editor.app.ts`, `assets` and `components`.
### `viewer.app.ts`
Entry point for Viewer Script file.

#### `initAppForPage`
A general call to the service where it should initiate its reusable data across components.
It's called with the basic configuration of the application before the Viewer knows which components exist on the page.

⚠️ You shouldn't use `createControllers`. We will generate it under the hood.

*src/viewer.app.ts*
```ts
export const initAppForPage = (initParams, platformApis, wixCodeApi, platformServicesApis) => {
  fetchExperiments();
  initStorage();
};
```

For more info related to `initAppForPage` check the [Viewer platform official docs](https://bo.wix.com/wix-docs/client/client-viewer-platform/articles/lifecycle#client-viewer-platform_articles_lifecycle_initappforpage)

### `editor.app.ts`
Entry point for Editor Script file.

*src/editor.app.ts*
```ts
export const editorReady = async (editorSDK, appDefinitionId, { origin, firstInstall }) => {
  const platform = new AppPlatform(editorSDK, appDefinitionId);

  if (firstInstall) {
    await platform.install();
  } else {
    await platform.hackForTemplates();
  }
};

export const getAppManifest = async () => {
  return getManifest();
};
```

For more info about editor platform script, please check [Editor Platform offical docs](https://bo.wix.com/wix-docs/client/editor-platform/editor-application-reference/editor-platform-app)


## Component level
According to the Yoshi Editor Flow concept, the app is grouped by components, instead of functional purpose. Since communitcation between different components (Widget, Page) in scope of single app is a rare case, people usually working on single Component while working on the new business feature.

So for now, we'll have `Widget`, `Settings` and `controller` in a single place, instead of having `settings` directory with all settings panels of your app. Or `viewerScript` directory, which will include all controllers. With last approach, it could be really hard to navigate between `controller` and `Widget` located in completely different directories or even projects, since Widget consumes properties passed by controller. You'll probably want to maintain `PublicData` in a single place also instead of switching between settings and widget directory.

### `.component.json`
Located under `src/components/:componentName/.component.json` this config file helps us to generate `createControllers` for Viewer Script under the hood. Here you can find `id` of your component and type (`WIDGET_OUT_OF_IFRAME`, `PAGE_OUT)OF_IFRAME` or `APP_STUDIO_WIDGET`).

### `controller`
File which `export default createController` function.

`createController` is called with useful arguments by platform.

Arguments:
#### `controllerConfig:` *(platform)* [IControllerInfo](https://bo.wix.com/wix-docs/client/client-viewer-platform/articles/lifecycle#client-viewer-platform_articles_lifecycle_controllerinfo)
##### `appData`: *(flow)*
Object which aims to use data for all controllers. This is a data that comes from `mapPlatformStateToAppData` method, which is being called before `createControllers`.

#### `flowData`: *(flow)*
Data with experiments, locations and other info being fetched.
##### `getExperiments`: `Promise<Experiments>`
Return a Promise, which will be resolved with `Experiments` instance for current scope.
Takes a configuration from `experiments` field in `.application.json`.

*Simple example*
*controller.ts*
```ts
export default async function createController({ flowData }) => {
  return {
    pageReady() {
      const experiments = await flowData.getExperiments();
      setProps({
        withNewButton: experiments.enabled('specs.my-scope.EnableNewButton'),
      });
    }
  };
}
```

*Parallel loading example*
*controller.ts*
```ts
export default async function createController({ flowData }) => {
  return {
    pageReady() {
      const [experiments, someData] = await Promise.all([
        flowData.getExperiments(),
        getSomeData(),
      ]);
      setProps({
        withNewButton: experiments.enabled('specs.my-scope.EnableNewButton'),
        someData,
      });
    }
  };
}
```

### `Widget`
File which `export default` React Component.

This component will be rendered in 2 different environments: viewer (common frame for the whole side) and editor (isolated iFrame).
The basic idea is that developers shouldn't be aware of this difference.
Just exporting a valid React Component and receiving a props from the controller's `setProps` will perfectly work.

*Widget.ts*
```tsx
export default ({ title }) => (<div>
  <h1>{title}</h1>
</div>)
```

*controller.ts*
```tsx
export default () => ({
  pageReady() {
    setProps({
      title: 'Some title from controller',
    });
  }
})
```

### `Settings`
*(optional)*

File which `export default` React Component.

It will be rendered in editor part. Via Settings panel app's user can configure Out-of-iFrame Widget.

It's recommend to use [`wix-base-ui`](https://github.com/wix-private/wix-base-ui) for styling and [TPA Settings](https://github.com/wix-private/tpa-settings) for reducing boilerplate relating to Settings panel development.

*Settings*
```tsx
import { TpaSettingsProvider } from '@wix/tpa-settings/dist/src/contexts';
import { SettingsTabLayout } from '@wix/tpa-settings/dist/src/components';
import { WixSDK } from 'yoshi-flow-editor-runtime';
import 'yoshi-flow-editor-runtime/styles/wix-base-ui.global.scss';

const Settings = () => {
  return (
    <WixSDK>{({ Wix }) => (
      <TpaSettingsProvider Wix={Wix}>
        <SettingsTabLayout>
          <SettingsTabLayout.Tab
            title={t('settings.tab.main')}
            articleId="78c122c7-ef06-47c1-a137-07abfae7ed89"
            Component={() => <MainTab />}
          />
        </SettingsTabLayout>
      </TpaSettingsProvider>
    )}</WixSDK>
  );
};

export default Settings;
```
